#include <Riostream.h>
#include <fstream>
#include "TMath.h"
#include <stdlib.h>
#include <fstream>
#include <math.h>
#include <TROOT.h>
#include <TApplication.h>
#include <TPaveLabel.h>
#include <TSystem.h>
#include <TFrame.h>
#include <TStyle.h>
#include <TString.h>
#include <string>
#include "TGaxis.h"
#include "TFractionFitter.h"
#include "TFile.h"
#include "TH1F.h"
#include "TH1D.h"
#include "TH2F.h"
#include "TH3F.h"
#include "TF1.h"
#include "THStack.h"
#include "TVirtualFitter.h"
#include "TObject.h"
#include "TCanvas.h"
#include "TMultiGraph.h"
#include "TLegend.h"
#include "TDatabasePDG.h"
#include "TMinuit.h"
#include "TLatex.h"
#include "TASImage.h"
#include "TPostScript.h"
#include "TGraphErrors.h"
#include "TArrow.h"
#include "TMarker.h"
#include "TGraphAsymmErrors.h" 
#include "TEllipse.h"
#include "TPaveText.h"
#include "TRandom3.h"
#include "Riostream.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TParticle.h"

void Read_Pythia_Tree_Exercise()
{
  //read the Tree generated by tree1w and fill two histograms
  TFile *f = new TFile("Pythia_ECM_14000GeV_hard_20_IsolatedPi0.root");
  TTree *tree = (TTree*)f->Get("tree");
  Int_t ev, ev2, pdgCode;
  Float_t px, py, pz, e, eta, phi;
  Int_t stackIDMother, stackID;
  tree->SetBranchAddress("ev",&ev);
  tree->SetBranchAddress("pdgCode",&pdgCode);
  tree->SetBranchAddress("px",&px);
  tree->SetBranchAddress("py",&py);
  tree->SetBranchAddress("pz",&pz);
  tree->SetBranchAddress("e",&e);
  tree->SetBranchAddress("eta",&eta);
  tree->SetBranchAddress("phi",&phi);
  tree->SetBranchAddress("stackIDMother", &stackIDMother);

  ofstream particles, Rout;
  particles.open ("particles.txt");
    
  gStyle->SetOptStat(0);
  gStyle->SetPadTickY(1);
  gStyle->SetPadTickX(1);
    
    TLatex T1;
    T1.SetTextSize(0.04);
    T1.SetTextAlign(12);
    T1.SetTextFont(42);
    T1.SetNDC();
   
  //create histograms
  TH1F *h_empty   = new TH1F("empty","",100,0,3);
  h_empty->GetXaxis()->SetTitle("p_{T} (GeV/c)");
  h_empty->GetYaxis()->SetTitle("N");
  h_empty->SetTitle("Transverse momentum spectrum");
  h_empty->GetYaxis()->SetMaxDigits(2);
  TH1F *h_empty_ratio   = new TH1F("empty","",100,0,3);
  h_empty_ratio->GetXaxis()->SetTitle("p_{T} (GeV/c)");
  h_empty_ratio->GetYaxis()->SetTitle("N");
  h_empty_ratio->SetTitle("Particle ratios");
//   h_empty_ratio->GetYaxis()->SetMaxDigits(2);
  TH1F *hpt_photon   = new TH1F("hpt_photon","photon pt",100,0,3);
  TH1F *hpt_pion   = new TH1F("hpt_pion","pion pt",100,0,3);
  TH1F *hpt_proton   = new TH1F("hpt_proton","proton pt",100,0,3);
  TH1F *hpt_kaon   = new TH1F("hpt_proton","proton pt",100,0,3);
  hpt_photon->SetLineColor(kBlack);
  hpt_photon->SetLineWidth(2);
  hpt_pion->SetLineColor(kRed);
  hpt_pion->SetLineWidth(2);
  hpt_proton->SetLineColor(kBlue);
  hpt_proton->SetLineWidth(2);
  hpt_kaon->SetLineColor(kGreen+2);
  hpt_kaon->SetLineWidth(2);    
    
  int nbins = 100;
  int chosenID = 2835;
    
//   Float_t bins[] = {0,0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2,0.21,0.22,0.23,0.24,0.25,0.26,0.27,0.28,0.29,0.3,0.31,0.32,0.33,0.34,0.35,0.36,0.37,0.38,0.39,0.4,0.41,0.42,0.43,0.44,0.45,0.46,0.47,0.48,0.49,0.5,0.51,0.52,0.53,0.54,0.55,0.56,0.57,0.58,0.59,0.6,0.61,0.62,0.63,0.64,0.65,0.66,0.67,0.68,0.69,0.7,0.71,0.72,0.73,0.74,0.75,0.76,0.77,0.78,0.79,0.8,0.81,0.82,0.83,0.84,0.85,0.86,0.87,0.88,0.89,0.9,0.91,0.92,0.93,0.94,0.95,0.96,0.97,0.98,0.99,1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3,4,5,6,7,8,9,10,20,30};//array for bins size 0-1 in steps of 0.01, 1-3 in steps of 0.1, 3-10 in steps of 1 and 10-30 in steps of 10 |total bins: 129|
  Float_t bins[] = {0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3,4,5,6,7,8,9,10,20,30};//array for bins size 0-3 in steps of 0.1, 3-10 in steps of 1 and 10-30 in steps of 10 |total bins: 39|
   
  TH1F *h_deltaPhi   = new TH1F("h_deltaPhi","delta Phi",100,0,4);
  TH1F *h_deltaEta   = new TH1F("h_deltaEta","delta Eta",100,0,4);
  TH2F *h_deltaEta_deltaPhi = new TH2F("Delta_Eta_Delta_Phi"," " , 100,0,4,100,0,4);
  TH2F *h_E_Pt = new TH2F("E_Pt","E Pt" , 1000,0,10,1000,0,10);
  h_E_Pt->GetXaxis()->SetTitle("E");
  h_E_Pt->GetYaxis()->SetTitle("P_{t}");
  TH2F *h_EIso_Pt = new TH2F("EIso_Pt","E Pt" , 1000,0,20,1000,0,20);
  h_EIso_Pt->GetXaxis()->SetTitle("E_{iso} [GeV]");
  h_EIso_Pt->GetYaxis()->SetTitle("#pi^{0} p_{T}  [GeV/c]");
  h_EIso_Pt->SetTitle("Isolation energy at p_{T} of #pi^{0}");
   
  TH2F *h_EvDis = new TH2F("h_EvDis","EvDis" , 100,-1.2,1.2,100,0,7);
  h_EvDis->GetXaxis()->SetTitle("Eta");
  h_EvDis->GetYaxis()->SetTitle("Phi");
  h_EvDis->SetTitle("Event display");
  
  TH2F *h_pE = new TH2F("h_pE","pE",100,0,10,1000,-0.1,1.1);
  h_pE->GetXaxis() ->SetTitle("#pi_{0} p_{T} (GeV/c)");
  h_pE->GetYaxis() ->SetTitle("Combined proton energy/E_{iso}");
  h_pE->SetTitle("proton energy fraction around #pi_{0}");
  TH2F *h_piE = new TH2F("h_piE","piE",100,0,10,1000,-0.1,1.1);
  h_piE->GetXaxis() ->SetTitle("#pi_{0} p_{T} (GeV/c)");
  h_piE->GetYaxis() ->SetTitle("Combined #pi energy/E_{iso}");
  h_piE->SetTitle("#pi energy fraction around #pi_{0}");
  TH2F *h_KE = new TH2F("h_KE","KE",100,0,10,1000,-0.1,1.1);
  h_KE->GetXaxis() ->SetTitle("#pi_{0} p_{T} (GeV/c)");
  h_KE->GetYaxis() ->SetTitle("Combined kaon energy/E_{iso}");
  h_KE->SetTitle("Kaon energy fraction around #pi_{0}");
  TH2F *h_eE = new TH2F("h_eE","eE",100,0,10,1000,-0.1,1.1);
  h_eE->GetXaxis() ->SetTitle("#pi_{0} p_{T} (GeV/c)");
  h_eE->GetYaxis() ->SetTitle("Combined electron energy/E_{iso}");
  h_eE->SetTitle("electron energy fraction around #pi_{0}");
  TH2F *h_particles = new TH2F("h_particles","particles",100,0,10,40,0,40);
  h_particles->GetXaxis() ->SetTitle("#pi_{0} p_{T} (GeV/c)");
  h_particles->GetYaxis() ->SetTitle("Number particles");
  h_particles->SetTitle("Number of particles around #pi_{0}");
   
  TH1F *h_EIso= new TH1F("h_EIso","E iso",1000,0,10);
  TH1F *h_E   = new TH1F("h_E","E tracks",1000,0,10);
   
  TH1F *h_PtIso= new TH1F("h_PtIso","Pt iso",1000,0,10);
  TH1F *h_Pt   = new TH1F("h_Pt","Pt tracks",1000,0,10);
    
  TH1F *h_allpi0= new TH1F("h_allpi0","p_{T} for all #pi^{0}",39,bins);
  TH1F *h_allisolatedpi0= new TH1F("h_allisolatedpi0","PT ALL pi0s (ISOLATED)",39,bins);
  TH1F *h_allnonisolatedpi0=new TH1F("h_allnonisolatedpi0","PT ALL pi0s (NON ISOLATED)",39,bins);
  h_allpi0->GetXaxis()->SetTitle("p_{T} (GeV/c)");
  h_allpi0->GetYaxis()->SetTitle("dN/dp_{T}");
  
  h_allpi0->SetLineColor(kBlack);
  h_allpi0->SetLineWidth(2);
  h_allpi0->SetMarkerColor(kBlack);
  h_allpi0->SetMarkerStyle(20);
  h_allpi0->SetMarkerSize(1);
  
  h_allisolatedpi0->SetLineColor(kRed+2);
  h_allisolatedpi0->SetLineWidth(2);
  h_allisolatedpi0->SetMarkerColor(kRed+2);
  h_allisolatedpi0->SetMarkerStyle(33);
  h_allisolatedpi0->SetMarkerSize(1.5);
  
  h_allnonisolatedpi0->SetLineColor(kBlue+2);
  h_allnonisolatedpi0->SetLineWidth(2);
  h_allnonisolatedpi0->SetMarkerColor(kBlue+2);
  h_allnonisolatedpi0->SetMarkerStyle(21);
  h_allnonisolatedpi0->SetMarkerSize(1);
   
  TH1F *h_R = new TH1F("h_R","R",nbins,0,4);
  TH1F *h_RA = new TH1F("h_RA","RA",nbins,0,4);
  TH1F *h_EIsoPro02 = new TH1F("h_EIsoPro02","EIsoPro02",1000,0,10);
  h_EIsoPro02->GetXaxis()->SetTitle("Isolation energy [GeV]");
  h_EIsoPro02->GetYaxis()->SetTitle("#N particles");
  h_EIsoPro02->SetTitle("Isolation energy at 0 < p_{T} < 2 [GeV/c]");
  TH1F *h_EIsoPro610 = new TH1F("h_EIsoPro610","EIsoPro610",1000,0,10);
  h_EIsoPro610->GetXaxis()->SetTitle("Isolation energy [GeV]");
  h_EIsoPro610->GetYaxis()->SetTitle("#N particles");
  h_EIsoPro610->SetTitle("Isolation energy at 4 < p_{T} < 10 [GeV/c]");
   
  TH1F *hpdgCode   = new TH1F("pdg code","",5000,-2500,2500);

  vector<TLorentzVector> v;
  TLorentzVector vec;
  Float_t phi1, phi2, dphi, R, RA;
  Float_t eta1, eta2, deta;
  Float_t EIso, PtIso;
  Int_t ParticlesFound, pcount;
  bool Printed = false;
  bool Printed2 = false;
   
  vector<int> pdgVec, momVec;
  Float_t pE, piE, KE, eE;
   
  tree->GetEntry(0);
  Int_t Nparticles = 0;
  Int_t eventID = ev;
  Float_t radius = 0.4;
  //read all entries and fill the histograms
  Long64_t nentries = tree->GetEntries();
  for (Long64_t i=0;i<nentries;i++) {
    tree->GetEntry(i); //load entry
    if(eventID != ev){
      //cout << "new event found with ID : " << ev << endl;
      //cout << "event had " << Nparticles << endl;
      Nparticles = 0;
      ParticlesFound = 0;
      eventID = ev;
      for(Int_t m=0 ; m<v.size(); m++){
        EIso = 0;
        PtIso = 0;
        pcount = 0;
        if(pdgVec.at(m)<10) continue; //exculdes pdg under 10 (quarks)
        phi1 = v.at(m).Phi();
        eta1 = v.at(m).Eta();
        if(phi1 < 0) phi1 += TMath::Pi()*2;
        if(abs(pdgVec.at(m)) != 211 && abs(pdgVec.at(m)) != 111 && abs(pdgVec.at(m)) != 2212 && abs(pdgVec.at(m)) != 321 && abs(pdgVec.at(m)) != 11) continue; //Allows only the selected particles to pass
        if(eventID==chosenID){
          if(!Printed){
            particles<<"Event found with ID: "<<eventID<<"."<< endl;
          }
          Printed=true;
          ParticlesFound++;
          if(pdgVec.at(m)==111){
            particles<<"Pi0";
          }
          if(pdgVec.at(m)==211){
            particles<<"Pi+";
          }
          if(pdgVec.at(m)==-211){
            particles<<"Pi-";
          }
          if(pdgVec.at(m)==321){
            particles<<"K+ ";
          }
          if(pdgVec.at(m)==-321){
            particles<<"K- ";
          }
          if(pdgVec.at(m)==2212){
            particles<<"p+ ";
          }
          if(pdgVec.at(m)==-2212){
            particles<<"p- ";
          }
          if(pdgVec.at(m)==11){
            particles<<"e- ";
          }
          if(pdgVec.at(m)==-11){
            particles<<"e+ ";
          }
          if(pdgVec.at(m)!=111 && abs(pdgVec.at(m)) != 211 && abs(pdgVec.at(m))!= 321 && abs(pdgVec.at(m)) != 2212 && abs(pdgVec.at(m)) != 11){
            particles<<pdgVec.at(m);
          }
          particles<<" found with pt = "<<v.at(m).Pt()<<" and eta = "<<eta1<<" and phi = "<<phi1<<endl;
          h_EvDis->Fill(eta1,phi1,v.at(m).Pt());
        }
        if(pdgVec.at(m)!=111 /*|| abs(eta1-radius)<1 || abs(eta1+radius)<1*/) continue; //only pass if you are a pi0
        for(Int_t n=0 ; n<v.size(); n++){
          if(n==m) continue; //don't compare with yourself
          if(abs(pdgVec.at(n)) != 211 && abs(pdgVec.at(n)) != 111 && abs(pdgVec.at(n)) != 2212 && abs(pdgVec.at(n)) != 321 && abs(pdgVec.at(n)) != 11) continue;
          if(v.at(n).E()<0.15) continue; //Checks for minumum particle energy
          h_E->Fill(v.at(n).E());
          h_Pt->Fill(v.at(n).Pt());
          h_E_Pt->Fill(v.at(n).E(),v.at(n).Pt());
          phi2 = v.at(n).Phi();
          eta2 = v.at(n).Eta();
          if(phi2 < 0) phi2 += TMath::Pi()*2;
          dphi = abs(phi1-phi2);
          deta = abs(eta1-eta2);
          if(dphi > TMath::Pi()) dphi = TMath::Pi()*2 - dphi;
          h_deltaPhi->Fill(dphi);
          h_deltaEta->Fill(deta);
          h_deltaEta_deltaPhi->Fill(deta,dphi);
          R = sqrt(pow(deta,2)+pow(dphi,2));
          if(v.at(m).Pt()>10){
            h_R->Fill(R);
          }
          if(R<radius){
            pcount++;
            EIso += v.at(n).E();
            PtIso += v.at(n).Pt();
            if (abs(pdgVec.at(n)) == 211 || pdgVec.at(n) == 111){
              piE += v.at(n).E();
            }
            if (abs(pdgVec.at(n)) == 321){
              KE += v.at(n).E();
            }
            if (abs(pdgVec.at(n)) == 2212){
              pE += v.at(n).E();
            }
            if (abs(pdgVec.at(n)) == 11){
              eE += v.at(n).E();
            }
          }
        }
        float p = 0;
          if(v.at(m).Pt()>(2/1.5)){
              p =1.5*v.at(m).Pt();
          }
          else p = 2;
         // cout<<"pt " << v.at(m).Pt() << " Isolation criteria " << p <<endl;
        h_EIso_Pt->Fill(EIso,v.at(m).Pt());
        if(EIso<p){
          h_allisolatedpi0->Fill(v.at(m).Pt());
          if(ev2!=eventID && v.at(m).Pt()>5){
           // cout<<"Event containing isolated pi0 found with ID: "<<eventID<<endl;
            ev2 = eventID;
          }
        }
        h_EIso->Fill(EIso);
        h_PtIso->Fill(PtIso);
        if(v.at(m).Pt()>0 && v.at(m).Pt()<2){
          h_EIsoPro02->Fill(EIso);
        }
        if(v.at(m).Pt()>4 && v.at(m).Pt()<10){
          h_EIsoPro610->Fill(EIso);
        }
        h_allpi0->Fill(v.at(m).Pt());
        if(EIso>p){
          piE = piE/EIso;
          h_piE->Fill(v.at(m).Pt(),piE);
          KE = KE/EIso;
          h_KE->Fill(v.at(m).Pt(),KE);
          pE = pE/EIso;
          h_pE->Fill(v.at(m).Pt(),pE);
          eE = eE/EIso;
          h_eE->Fill(v.at(m).Pt(),eE);
          h_allnonisolatedpi0->Fill(v.at(m).Pt());
          h_particles->Fill(v.at(m).Pt(), pcount);
//            if(abs(v.at(m).Pt()-10)<0.1){
//            cout<<"Non-isolated event with a Pt around 2 found with ID: "<<eventID<<endl;
//            }
        }
        piE=0;
        KE=0;
        pE=0;
        eE=0;
      }
      Printed=false;
      v.clear();
      pdgVec.clear();
      momVec.clear();
    }
    if(abs(eta)>1) continue;
    if(pdgCode == 22){
      hpt_photon->Fill(TMath::Sqrt(px*px+py*py));
    }
    if(pdgCode == 111){
      hpt_pion->Fill(TMath::Sqrt(px*px+py*py));
    }
    if(pdgCode == 2212 || pdgCode == -2212){
      hpt_proton->Fill(TMath::Sqrt(px*px+py*py));
    }
    if(pdgCode == 321 || pdgCode == -321){
      hpt_kaon->Fill(TMath::Sqrt(px*px+py*py));
    }
    hpdgCode->Fill(pdgCode);
    Nparticles++;
    vec.SetPxPyPzE(px,py,pz,e);
    v.push_back(vec);
    pdgVec.push_back(pdgCode);
    momVec.push_back(stackIDMother);

//  if(eventID!=chosenID&&!Printed2&&ParticlesFound!=0){
//    particles<<"Event concluded, found "<<ParticlesFound<<" particles."<<endl;
//    particles<<" "<<endl;
//    Printed2 = true;
//  }
  }
  particles.close();
  for(Int_t n=0; n<nbins; n++){
    Float_t CenterValue = 0;
    Float_t BinValue = 0;
    Float_t RAdjusted = 0;
    CenterValue = h_R->GetXaxis()->GetBinCenter(n+1);
    BinValue = h_R->GetBinContent(n+1);
    RAdjusted = BinValue/(pow(CenterValue,2));
    h_RA->Fill(CenterValue, RAdjusted);
    h_RA->SetBinError(n+1,0);
  }

  h_empty->GetYaxis()->SetRangeUser(1,hpt_photon->GetMaximum()*1.2);
  h_empty_ratio->GetYaxis()->SetRangeUser(0.01,.3);
  
  TH1F *k_Ratio_kaon_pion = (TH1F*)hpt_kaon->Clone("");
  k_Ratio_kaon_pion->Divide(k_Ratio_kaon_pion,hpt_pion,1,1,"B");
  TH1F *k_Ratio_proton_pion = (TH1F*)hpt_proton->Clone("");
  k_Ratio_proton_pion->Divide(k_Ratio_proton_pion,hpt_pion,1,1,"B");
  
//   h_allpi0->Rebin(50);
//   h_allisolatedpi0->Rebin(50);
//   h_allnonisolatedpi0->Rebin(50);
  for(Int_t b=0; b<h_allpi0->GetSize()-2; b++){
    h_allpi0->SetBinContent(b+1,h_allpi0->GetBinContent(b+1)/h_allpi0->GetBinWidth(b+1));
    h_allisolatedpi0->SetBinContent(b+1,h_allisolatedpi0->GetBinContent(b+1)/h_allisolatedpi0->GetBinWidth(b+1));
    h_allnonisolatedpi0->SetBinContent(b+1,h_allnonisolatedpi0->GetBinContent(b+1)/h_allnonisolatedpi0->GetBinWidth(b+1));
  }
    
  TH1F *k_allpi0non = (TH1F*)h_allnonisolatedpi0->Clone();
  k_allpi0non->Divide(h_allnonisolatedpi0,h_allpi0,1,1,"B");
    
  TH1F *k_allpi0iso = (TH1F*)h_allisolatedpi0->Clone();
  k_allpi0iso->Divide(h_allisolatedpi0,h_allpi0,1,1,"B");
            
  for(Int_t b=0; b<k_allpi0non->GetEntries(); b++){
    k_allpi0non->SetBinError(b+1,0);
    k_allpi0iso->SetBinError(b+1,0);
  }
  
  Rout.open("r < "+std::to_string(radius)+".txt");
  Rout<<"Ratios for R < "<< radius <<endl;
  Rout<<"Bin number   Ratio isolated   Ratio nonisolated"<<endl;
  for(Int_t r=0; r<k_allpi0non->GetSize()-2; r++){
    Rout<<r+1<<"             "<<k_allpi0iso->GetBinContent(r+1)<<"         "<<k_allpi0non->GetBinContent(r+1)<<endl;
  }
  Rout.close();
  
  k_allpi0non->SetTitle("p_{T} for all #pi^{0} ratios");
  k_allpi0non->GetXaxis()->SetTitle("p_{T} [GeV/c]");
  k_allpi0non->GetYaxis()->SetTitle("ratio"); 

  cout<<"Ratio of completely isolated particles to total amount of particles is: "<< h_EIso->GetBinContent(1)/h_EIso->GetEntries()<<endl;
  
  TLegend* leg1 = new TLegend(0.7,0.7,0.85,0.85);
  leg1->SetTextSize(0.04);
  leg1->AddEntry(hpt_photon,"#gamma","l");
  leg1->AddEntry(hpt_pion,"#pi^{0}","l");
  leg1->AddEntry(hpt_kaon,"K^{#pm}","l");
  leg1->AddEntry(hpt_proton,"p(#bar{p})","l");
  leg1->SetBorderSize(0);
  
  TLegend* leg2 = new TLegend(0.7,0.7,0.85,0.85);
  leg2->SetTextSize(0.04);
  leg2->AddEntry(hpt_kaon,"K^{#pm}/#pi^{0}","l");
  leg2->AddEntry(hpt_proton,"p(#bar{p})/#pi^{0}","l");
  leg2->SetBorderSize(0);
  
  TLegend* leg3 = new TLegend(0.7,0.7,0.85,0.85);
  leg3->SetTextSize(0.04);
  leg3->AddEntry(h_allpi0,"#pi^{0}","pl");
  leg3->AddEntry(h_allisolatedpi0,"#pi_{iso}^{0}","pl");
  leg3->AddEntry(h_allnonisolatedpi0,"#pi_{non iso}^{0}","pl");
  leg3->SetBorderSize(0);
     
  TLegend* leg4 = new TLegend(0.6,0.425,0.75,0.575);
  leg4->SetTextSize(0.04);
  leg4->AddEntry(k_allpi0non,"n.i. #pi^{0}/all #pi^{0}","pl");
  leg4->AddEntry(k_allpi0iso,"iso #pi^{0}/all #pi^{0}","pl");
  leg4->SetBorderSize(0);
  
  TLegend* leg5 = new TLegend(0.70,0.25,0.85,0.75);
  leg5->SetTextSize(0.04);
  leg5->SetBorderSize(0);
  
  TF1* f1 = new TF1("f1" , "pol0" , 1.5, 3);
  TF1* f2 = new TF1("f2" , "pol0" , 1.5, 3);
  
  //creating the canvas
   TCanvas* c1 = new TCanvas("c1","",800,800);
   c1->cd();
   gPad->SetLeftMargin(0.12);
   gPad->SetRightMargin(0.02);
   gPad->SetBottomMargin(0.11);
   h_empty->Draw();
   hpt_photon->Draw("SAME");
   hpt_pion->Draw("SAME");
   hpt_proton->Draw("SAME");
   hpt_kaon->Draw("SAME");
   leg1->Draw();
   TCanvas* c2 = new TCanvas("c2","",800,800);
   c2->cd();
   hpdgCode->Draw("SAME");
   TCanvas* c3 = new TCanvas("c3","",800,800);
   c3->cd();
   h_deltaPhi->Draw();
   TCanvas* c4 = new TCanvas("c4","",800,800);
   c4->cd();
   h_deltaEta->Draw();
   TCanvas* c5 = new TCanvas("c5","",800,800);
   c5->cd();
   h_empty_ratio->Draw();
   k_Ratio_kaon_pion->Draw("SAME");
   k_Ratio_kaon_pion->Fit("f1","R");
   k_Ratio_proton_pion->Draw("SAME");
   k_Ratio_proton_pion->Fit("f2","R");
   leg2->Draw();
   TCanvas* c6 = new TCanvas("c6","",800,800);
   h_deltaEta_deltaPhi->Draw("colz");
   TCanvas* c7 = new TCanvas("c7","",800,800);
   c7->cd();
   h_R->Draw("SAME");
   TCanvas* c8 = new TCanvas("c8","",800,800);
   c8->cd();
   h_EIso->Draw();
   TCanvas* c9 = new TCanvas("c9","",800,800);
   c9->cd();
   h_E->Draw();
   TCanvas* c10 = new TCanvas("c10","",800,800);
   c10->cd();
   h_RA->Draw("SAME");
   TCanvas* c11 = new TCanvas("c11","",800,800);
   c11->cd();
   h_PtIso->Draw();
   TCanvas* c12 = new TCanvas("c12","",800,800);
   c12->cd();
   h_Pt->Draw();
   TCanvas* c13 = new TCanvas("c13","",800,800);
   h_E_Pt->Draw("colz");
   TCanvas* c14 = new TCanvas("c14","",800,800);
   h_EIso_Pt->Draw("colz");
   TCanvas* c15 = new TCanvas("c15","",800,400);
   c15->cd();
   h_EIsoPro02->Draw();
   TCanvas* c16 = new TCanvas("c16","",800,400);
   c16->cd();
   h_EIsoPro610->Draw();
   TCanvas* c17 = new TCanvas("c17","",800,800);
   h_EvDis->Draw("colz");
   TCanvas* c18 = new TCanvas("c18","",800,800);
   h_allpi0->Draw("SAME P");
   h_allisolatedpi0->Draw("SAME P");
   h_allnonisolatedpi0->Draw("SAME P");
   c18->SetLogy();
   leg3->Draw();
   TCanvas* c19 = new TCanvas("c19","",800,800);
   k_allpi0non->SetAxisRange(-0.2,1.2,"Y");
   k_allpi0non->Draw("SAME P");
   k_allpi0iso->Draw("SAME P");
   leg4->Draw();
  TCanvas* c20 = new TCanvas("c20","",800,800);
  h_pE->Draw("colz");
  c20->SetLogz();
  TCanvas* c21 = new TCanvas("c21","",800,800);
  h_piE->Draw("colz");
  c21->SetLogz();
  TCanvas* c22 = new TCanvas("c22","",800,800);
  h_KE->Draw("colz");
  c22->SetLogz();
  TCanvas* c24 = new TCanvas("c24","",800,800);
  h_eE->Draw("colz");
  c24->SetLogz();
  TCanvas* c25 = new TCanvas("c25","",800,800);
  h_particles->Draw("colz");
  c25->SetLogz();
  
    //creating an output file to which we store all the objects that we used
  TFile *outputFile = new TFile("outputFile.root","UPDATE");
  k_allpi0non->Write("allnonisoratio");
  k_allpi0iso->Write("allisoratio");
  f1->Write("f1");
  outputFile->Close();
  
     //Make ratio plot with multiple values for R   
  TFile *g = new TFile("outputFile.root");
  TCanvas*c99 = new TCanvas("c99", "ratio", 200,10,700,500);
  TH1F * RATIOS = new TH1F("RATIOS", "all ratios" , 100, 0, 4); 
    
  TH1F *h_empty2   = new TH1F("empty2","",100,0,20);
  h_empty2->GetXaxis()->SetTitle("#pi^{0} p_{T} (GeV/c)");
  h_empty2->GetYaxis()->SetTitle("Ratio");
  h_empty2->GetYaxis()->SetMaxDigits(2);
  h_empty2->GetXaxis()->SetRangeUser(0.2,30);
  h_empty2->Draw();
  h_empty2->GetYaxis()->SetRangeUser(0.0,1.2);
      T1.DrawLatex(0.25, 0.80,"E_{Iso} = 2 GeV, with the radius varying from R = 0.1 to R = 0.5");
   
 leg5->AddEntry((TObject*)0, "non-iso", "");
    
    RATIOS = (TH1F*)g->Get("allnonisoratio;1");
    RATIOS->SetLineColor(kBlue+2);
    RATIOS->SetMarkerStyle(29);
    RATIOS->SetMarkerSize(1);
    RATIOS->SetMarkerColor(kBlue+2);
    leg5->AddEntry(RATIOS, "0.1 ", "pl");
    RATIOS->Draw("SAME P");
    
    RATIOS = (TH1F*)g->Get("allnonisoratio;2");
    RATIOS->SetLineColor(kOrange);
    RATIOS->SetMarkerStyle(33);
    RATIOS->SetMarkerSize(1);
    RATIOS->SetMarkerColor(kOrange);
    leg5->AddEntry(RATIOS, "0.2", "pl");
    RATIOS->Draw("SAME P");
    
    RATIOS = (TH1F*)g->Get("allnonisoratio;3");
    RATIOS->SetLineColor(kMagenta+2);
    RATIOS->SetMarkerStyle(41);
    RATIOS->SetMarkerSize(1);
    RATIOS->SetMarkerColor(kMagenta+2);
    leg5->AddEntry(RATIOS, "0.3", "pl");
    RATIOS->Draw("SAME P");
    
    RATIOS = (TH1F*)g->Get("allnonisoratio;4");
     RATIOS->SetLineColor(kPink-2);
     RATIOS->SetMarkerStyle(20);
     RATIOS->SetMarkerSize(1);
     RATIOS->SetMarkerColor(kPink-2);
     leg5->AddEntry(RATIOS, "0.4", "pl");
     RATIOS->Draw("SAME P");
    
    
  RATIOS = (TH1F*)g->Get("allnonisoratio;5");
  RATIOS->SetLineColor(kGreen+1);
  RATIOS->SetMarkerStyle(21);
  RATIOS->SetMarkerSize(1);
  RATIOS->SetMarkerColor(kGreen+1);
  leg5->AddEntry(RATIOS, "0.5 ", "pl");
  RATIOS->Draw("SAME P");

  

  

  

    
     leg5->AddEntry((TObject*)0, "", "");
    leg5->AddEntry((TObject*)0, "iso", "");
  
  RATIOS = (TH1F*)g->Get("allisoratio;1");
  RATIOS->SetLineColor(kBlue+2);
  RATIOS->SetMarkerStyle(30);
  RATIOS->SetMarkerSize(1);
  RATIOS->SetMarkerColor(kBlue+2);
  leg5->AddEntry(RATIOS, "0.1", "pl");
  RATIOS->Draw("SAME P");
  
  RATIOS = (TH1F*)g->Get("allisoratio;2");
  RATIOS->SetLineColor(kOrange);
  RATIOS->SetMarkerStyle(27);
  RATIOS->SetMarkerSize(1);
  RATIOS->SetMarkerColor(kOrange);
  leg5->AddEntry(RATIOS, "0.2", "pl");
  RATIOS->Draw("SAME P");
    
    
  
  RATIOS = (TH1F*)g->Get("allisoratio;3");
  RATIOS->SetLineColor(kMagenta+2);
  RATIOS->SetMarkerStyle(40);
  RATIOS->SetMarkerSize(1);
  RATIOS->SetMarkerColor(kMagenta+2);
  leg5->AddEntry(RATIOS, "0.3", "pl");
  RATIOS->Draw("SAME P");
  
  RATIOS = (TH1F*)g->Get("allisoratio;4");
  RATIOS->SetLineColor(kPink-2);
  RATIOS->SetMarkerStyle(24);
  RATIOS->SetMarkerSize(1);
  RATIOS->SetMarkerColor(kPink-2);
  leg5->AddEntry(RATIOS, "0.4", "pl");
  RATIOS->Draw("SAME P");
  
  RATIOS = (TH1F*)g->Get("allisoratio;5");
  RATIOS->SetLineColor(kGreen+2);
  RATIOS->SetMarkerStyle(25);
  RATIOS->SetMarkerSize(1);
  RATIOS->SetMarkerColor(kGreen+2);
  leg5->AddEntry(RATIOS, "0.5", "psl");
  RATIOS->Draw("SAME P");
  
  leg5->Draw("SAME"); 
}
